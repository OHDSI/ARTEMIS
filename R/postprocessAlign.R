#' Creates a plottable data frame from a drug record
#' @param drugRec A drug record
#' @export
#' @return A data.table object with drugs
#'
createDrugDF <- function(drugRec){

  drugDF <- as.data.frame(t(as.data.frame(drugRec, col.names = c(seq(1:length(drugRec))))))
  drugDF[1,]$V1 <- 0

  #Assign each individual drug an occurrence period of roughly one day
  drugDF$t_start <- cumsum(drugDF$V1)
  drugDF$regimen <- "No"
  drugDF$index <- c(1:length(drugDF$V1))

  #Assign each block a y-height
  drugDF$ymin <- -0.5
  drugDF$ymax <- 0.5
  j <- 0

  for(i in unique(drugDF$V2)){
    drugDF[drugDF$V2 == i,]$ymin <- drugDF[drugDF$V2 == i,]$ymin + (j*1.25)
    drugDF[drugDF$V2 == i,]$ymax <- drugDF[drugDF$V2 == i,]$ymax + (j*1.25)
    j = j + 1
  }

  colnames(drugDF) <- c("t_gap", "component", "t_start", "regimen", "index", "ymin", "ymax")

  drugDF$t_start <- as.numeric(drugDF$t_start)
  drugDF$t_end <- as.numeric(drugDF$t_start+0.9)
  drugDF$ymin <- as.numeric(drugDF$ymin)
  drugDF$ymax <- as.numeric(drugDF$ymax)

  return(drugDF)

}

#' Calculates the number of unique aligned drugs in a regimen
#'
no_unique_aligned_drugs <- function(regimen) {
    
    s = gsub("[0-9]*\\.", "", regimen)
    
    s = unlist(strsplit(s, ";|~"))
    s = s[s!="__"]
    return(length(unique(s)))
}

#' Prepare data.frame for postproccessing. 
#'
#' @param output An output dataframe created by align()
#' @param drugDF A drugDF object generated by createDrugDF()
#' 
#' 
prepareDF <- function(output, drugDF) {
    
    df <- output %>%
        dplyr::distinct() %>%
        dplyr::filter(Score != "") %>%
        dplyr::select(personID, regName, shortString, Regimen, Score,
                      drugRec_Start, drugRec_End, adjustedS, totAlign)

    print(str(df))
        
    # Convert columns to numeric
    df <- df %>%
      dplyr::mutate(across(c(drugRec_Start, drugRec_End, totAlign, Score, adjustedS), as.numeric))
    
    df <- df %>%
        dplyr::arrange(drugRec_Start)

    # Ensure drugRec_Start and drugRec_End are within valid range
    df <- df %>%
      dplyr::mutate(drugRec_Start = ifelse(drugRec_Start <= 0, 1, drugRec_Start),
                    drugRec_End = ifelse(drugRec_End > max(drugDF$index), max(drugDF$index), drugRec_End))
 

    df$t_start <- drugDF[df$drugRec_Start,]$t_start
    df$t_end <- drugDF[df$drugRec_End,]$t_start
    
    return(df)
}

#' Removes overlapping regimens from alignment output
#'
#' Three overlap removal steps are performed:
#' #' 1. Remove overlaps between regimens with different names  
#' #' 2. Remove overlaps between regimens with different number of components
#' #' 3. Remove overlaps between regimens with the same name, same total alignment length, but different scores
#' @param df A dataframe created by align() and processed by prepareDF()
#' @export
#' @return A data.table object with removed overlaps
#' @importFrom data.table :=
#' @importFrom data.table .I
#' 
removeOverlaps <- function(df) {
    # get number of components in each regimen variant
    regCount <- df %>%
        rowwise() %>%
        mutate(
            compNo = no_unique_aligned_drugs(Regimen) 
        ) %>%
        select(regName, Regimen, compNo) %>% 
        dplyr::distinct()

    # Convert to data.table to do overlap and drop lower scored regimens
    data.table::setDT(df)
    data.table::setorder(df, drugRec_Start, drugRec_End)
    df[, index := .I]
    
    df_overlap <- data.table::copy(df)
    data.table::setkey(df_overlap, drugRec_Start, drugRec_End)
    
    # Find overlaps where regName is different
    overlaps <- data.table::foverlaps(df, df_overlap, nomatch = 0, 
                          by.x = c("drugRec_Start", "drugRec_End"), 
                          by.y = c("drugRec_Start", "drugRec_End"))
    overlaps <- overlaps[regName != i.regName & index < i.index]
    removed <- integer(0)
    
    # Process overlaps row-wise and remove lower scored regimens
    for (row in seq_len(nrow(overlaps))) {
        i <- overlaps$index[row]
        j <- overlaps$i.index[row]
        
        if (i %in% removed || j %in% removed) next
        
        i_score <- overlaps$adjustedS[row]
        j_score <- overlaps$i.adjustedS[row]
        
        if (i_score < j_score) {
            removed <- c(removed, i)
        } else if (j_score < i_score) {
            removed <- c(removed, j)
        }
    }
    
    df <- df[!index %in% removed]
    df[, index := NULL]

    # SECOND overlap removal - removing low component high scoring regimens
    # compNo - number of components
    data.table::setDT(regCount)
    df <- merge(df, regCount, by = c("regName", "Regimen"))
    df[, index := .I]
    data.table::setorder(df, t_start, t_end)
    df_overlap <- data.table::copy(df)
    data.table::setkey(df_overlap, t_start, t_end)

    overlaps <- data.table::foverlaps(df, df_overlap, nomatch = 0, 
                          by.x = c("t_start", "t_end"), 
                          by.y = c("t_start", "t_end"))
    
    # Exclude self-overlaps
    overlaps <- overlaps[index != i.index]
    toRemove <- overlaps[compNo != i.compNo, 
                         .(remove = ifelse(compNo < i.compNo, index, i.index))]$remove
    
    df <- df[!index %in% toRemove]
    
    # Final overlap removal - sub-regimens
    # Ensure sorted order for foverlaps
    
    data.table::setorder(df, t_start, t_end)
    df_overlap <- data.table::copy(df)
    data.table::setkey(df_overlap, t_start, t_end)
    
    # Find overlapping intervals
    overlaps <- data.table::foverlaps(df, df_overlap, nomatch = 0, 
                          by.x = c("t_start", "t_end"), 
                          by.y = c("t_start", "t_end"))
    
    # Exclude self-overlaps and one position overlaps
    overlaps <- overlaps[index < i.index,]
    overlaps <- overlaps[t_start != i.t_end & t_end != i.t_start,]
    
    overlaps <- overlaps[regName == i.regName & totAlign == i.totAlign,]
    overlaps <- overlaps[adjustedS != i.adjustedS,]
    toRemove <- overlaps[,.(remove = ifelse(adjustedS < i.adjustedS, index, i.index))]$remove
    
    df <- df[!index %in% toRemove][order(t_start)]
    df[, index := NULL]
    df <- as.data.frame(df)
    return(df)
}

#' Combines overlapping regimens from alignment output
#'
#' @param output An output dataframe created by align()
#' @param regimenCombine Allowed days between same regimen before being combined
#' @export
#' 
combineOverlaps <- function(df, regimenCombine) {
    
    # Regimen Combine - overall combine
        
    dt <- df
    data.table::setDT(dt)

    # We only merge same regimens, next to each other chronologically 
    # We sort chronologically
    # Create id for consecutive regimens and remove if distance is larger than regimenCombine
    # TODO: remove regName to disable regimen overlap 
    data.table::setorder(dt, regName, t_start, t_end)

    dt[, run_id := cumsum(
        c(TRUE, regName[-1] != regName[-.N] | (t_start[-1] - t_end[-.N]) >= regimenCombine)
    )]
    
    dt <- dt[, .(
              drugRec_Start = min(drugRec_Start),
              drugRec_End   = max(drugRec_End),
              t_start       = min(t_start),
              t_end         = max(t_end),
              adjustedS     = mean(adjustedS),
              Score         = mean(Score),
              totAlign      = sum(totAlign)
            ), by = .(personID, regName, run_id)
            ][, run_id := NULL][, component := regName]


      return(as.data.frame(dt))
}


#' Postprocess alignment output
#'
#' @param output An output dataframe created by align()
#' @param regimenCombine Allowed number of days between two instances of the same regimen before
#' @return df - A data.frame object
#' @export
#' 
postprocessDF <- function(output, regimenCombine = 28) {

  drugRec <- encode(output[is.na(output$Score)|output$Score=="",][1,]$DrugRecord)

  output <- output %>%
    dplyr::distinct()

  drugDF <- createDrugDF(drugRec)
  df <- prepareDF(output, drugDF)    

  df <- removeOverlaps(df)
  df <- combineOverlaps(df, regimenCombine)

  df$timeToNextRegimen <- 0
  df$timeToEOD <- 0
  

  endOfData <- max(drugDF$t_start)
  df <- df %>%
      dplyr::arrange(t_start) %>%
      dplyr::mutate(timeToNextRegimen = dplyr::lead(t_start) - t_end)

  df[nrow(df),]$timeToEOD <- endOfData - df[nrow(df),]$t_end

  return(df)                
}